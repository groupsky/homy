name: Cascade Base Image Updates

on:
  # Run when base images are updated
  push:
    branches:
      - master
    paths:
      - 'base-images/**/Dockerfile'

  # Allow manual trigger
  workflow_dispatch:
    inputs:
      baseImage:
        description: 'Base image to cascade (e.g., node-18-alpine, node-22-alpine)'
        required: false
        type: string
      dryRun:
        description: 'Dry run (print changes without creating PR)'
        required: false
        default: false
        type: boolean

jobs:
  detect-and-cascade:
    name: Detect and Cascade Base Image Updates
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6.0.2
        with:
          fetch-depth: 2  # Need previous commit to detect changes

      - name: Detect changed base images
        id: detect
        run: |
          if [ -n "${{ inputs.baseImage }}" ]; then
            # Manual trigger with specific base image
            CHANGED_IMAGES="${{ inputs.baseImage }}"
            echo "Manually specified base image: $CHANGED_IMAGES"
          else
            # Detect from git diff
            CHANGED_IMAGES=$(git diff --name-only HEAD~1 HEAD | \
              grep '^base-images/.*/Dockerfile$' | \
              sed 's|^base-images/||' | \
              sed 's|/Dockerfile$||' | \
              sort -u | \
              tr '\n' ' ')
            echo "Detected changed base images from git diff: $CHANGED_IMAGES"
          fi

          if [ -z "$CHANGED_IMAGES" ]; then
            echo "No base image changes detected"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "changed_images=$CHANGED_IMAGES" >> $GITHUB_OUTPUT
          echo "has_changes=true" >> $GITHUB_OUTPUT

      - name: Extract base image versions
        if: steps.detect.outputs.has_changes == 'true'
        id: versions
        run: |
          CHANGED_IMAGES="${{ steps.detect.outputs.changed_images }}"

          for base_image in $CHANGED_IMAGES; do
            dockerfile="base-images/$base_image/Dockerfile"

            if [ ! -f "$dockerfile" ]; then
              echo "Warning: $dockerfile not found, skipping"
              continue
            fi

            # Extract version from FROM line
            version=$(grep -E '^FROM ' "$dockerfile" | head -1 | sed -E 's/FROM [^:]+:([0-9.]+).*/\1/')

            if [ -z "$version" ]; then
              echo "Warning: Could not extract version from $dockerfile"
              continue
            fi

            echo "$base_image=$version"
            echo "${base_image}_version=$version" >> $GITHUB_OUTPUT
          done

      - name: Find services using updated base images
        if: steps.detect.outputs.has_changes == 'true'
        id: find-services
        run: |
          CHANGED_IMAGES="${{ steps.detect.outputs.changed_images }}"
          SERVICES_TO_UPDATE=""

          for base_image in $CHANGED_IMAGES; do
            # Map base image name to GHCR image pattern
            # e.g., node-18-alpine -> ghcr.io/groupsky/homy/node:18.*-alpine
            pattern=$(echo "$base_image" | sed -E 's/node-([0-9]+)-.*/ghcr.io\/groupsky\/homy\/node:\1.*/')

            echo "Searching for services using pattern: $pattern"

            # Find Dockerfiles that use this base image
            services=$(grep -l -E "FROM $pattern" docker/*/Dockerfile | \
              sed 's|docker/||' | \
              sed 's|/Dockerfile||' | \
              sort -u | \
              tr '\n' ' ')

            if [ -n "$services" ]; then
              echo "Found services using $base_image: $services"
              SERVICES_TO_UPDATE="$SERVICES_TO_UPDATE $services"
            fi
          done

          SERVICES_TO_UPDATE=$(echo "$SERVICES_TO_UPDATE" | tr ' ' '\n' | sort -u | tr '\n' ' ')

          if [ -z "$SERVICES_TO_UPDATE" ]; then
            echo "No services found using the updated base images"
            echo "has_services=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "services=$SERVICES_TO_UPDATE" >> $GITHUB_OUTPUT
          echo "has_services=true" >> $GITHUB_OUTPUT

      - name: Update service Dockerfiles
        if: steps.find-services.outputs.has_services == 'true' && inputs.dryRun != true
        run: |
          CHANGED_IMAGES="${{ steps.detect.outputs.changed_images }}"
          SERVICES="${{ steps.find-services.outputs.services }}"

          for base_image in $CHANGED_IMAGES; do
            # Get the new version
            version_var="${base_image}_version"
            new_version=$(echo "${{ steps.versions.outputs[version_var] }}")

            if [ -z "$new_version" ]; then
              echo "Warning: No version found for $base_image, skipping"
              continue
            fi

            echo "Updating services to use $base_image version $new_version"

            for service in $SERVICES; do
              dockerfile="docker/$service/Dockerfile"

              if [ ! -f "$dockerfile" ]; then
                continue
              fi

              # Check if this service uses this base image
              if ! grep -q "ghcr.io/groupsky/homy/node" "$dockerfile"; then
                continue
              fi

              # Extract current version
              current_version=$(grep -E 'FROM ghcr.io/groupsky/homy/node' "$dockerfile" | \
                sed -E 's/.*node(-[a-z]+)?:([0-9.]+).*/\2/' | head -1)

              if [ "$current_version" = "$new_version" ]; then
                echo "  $service: already at version $new_version, skipping"
                continue
              fi

              echo "  $service: updating $current_version -> $new_version"

              # Update the Dockerfile
              sed -i -E "s|(FROM ghcr.io/groupsky/homy/node(-[a-z]+)?:)[0-9.]+|\1$new_version|g" "$dockerfile"

              # Update .nvmrc if it exists
              if [ -f "docker/$service/.nvmrc" ]; then
                echo "$new_version" > "docker/$service/.nvmrc"
                echo "  $service: updated .nvmrc to $new_version"
              fi
            done
          done

      - name: Create Pull Request
        if: steps.find-services.outputs.has_services == 'true' && inputs.dryRun != true
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: 'chore(deps): cascade base image updates to services'
          branch: 'renovate/cascade-base-image-updates'
          delete-branch: true
          title: 'chore(deps): Cascade base image updates to services'
          body: |
            ## Base Image Update Cascade

            This PR automatically updates service Dockerfiles and .nvmrc files to match updated base images.

            ### Changed Base Images
            ${{ steps.detect.outputs.changed_images }}

            ### Updated Services
            ${{ steps.find-services.outputs.services }}

            ### Changes
            - Updated service Dockerfiles to use new base image versions
            - Synced .nvmrc files to match Dockerfile Node.js versions

            ---
            **Auto-generated by cascade-base-image-updates workflow**
          labels: |
            dependencies
            automated
          assignees: groupsky

      - name: Dry Run Summary
        if: inputs.dryRun == true
        run: |
          echo "=== DRY RUN MODE ==="
          echo "Changed base images: ${{ steps.detect.outputs.changed_images }}"
          echo "Services to update: ${{ steps.find-services.outputs.services }}"
          echo ""
          echo "No PR will be created in dry run mode."
